# 요구사항 문서

## 소개

이 문서는 블로그의 마크다운 렌더링 기능을 향상시키기 위한 요구사항을 정의합니다. 현재 블로그는 MDX 콘텐츠를 렌더링하고 있지만, 코드 블록 상호작용, 목차 네비게이션, 읽기 시간 표시 등의 고급 기능이 부족합니다. 이러한 기능들은 사용자 경험을 크게 개선하고 콘텐츠의 가독성을 높일 것입니다.

## 용어 정의

- **System**: 블로그 애플리케이션 (Next.js 기반)
- **MDX**: Markdown with JSX - 마크다운 문서에 React 컴포넌트를 포함할 수 있는 형식
- **AST**: Abstract Syntax Tree - 마크다운 문서의 구조를 트리 형태로 표현한 것
- **TOC**: Table of Contents - 문서의 목차
- **Heading**: 마크다운의 제목 요소 (h1, h2, h3 등)
- **Code Block**: 마크다운의 코드 블록 (```로 감싸진 영역)
- **Reading Time**: 문서를 읽는 데 걸리는 예상 시간
- **Clipboard API**: 브라우저의 클립보드 접근 API
- **Intersection Observer**: 요소의 가시성을 감지하는 브라우저 API

## 요구사항

### 요구사항 1

**사용자 스토리:** 독자로서, 블로그 포스트에서 코드 스니펫을 쉽게 복사하고 싶습니다. 그래야 수동으로 선택하지 않고도 내 프로젝트에서 빠르게 사용할 수 있습니다.

#### 수용 기준

1. WHEN 코드 블록이 렌더링되면, THE System SHALL 코드 블록 내부 또는 인접한 위치에 복사 버튼을 표시한다
2. WHEN 사용자가 복사 버튼을 클릭하면, THE System SHALL Clipboard API를 사용하여 코드 내용을 클립보드에 복사한다
3. WHEN 복사 작업이 성공하면, THE System SHALL 성공적인 복사를 나타내는 시각적 피드백을 제공한다
4. WHEN 복사 작업이 실패하면, THE System SHALL 실패를 나타내는 시각적 피드백을 제공한다
5. WHERE 브라우저가 Clipboard API를 지원하지 않으면, THE System SHALL 폴백 메커니즘을 제공하거나 복사 버튼을 비활성화한다

### 요구사항 2

**사용자 스토리:** 독자로서, 코드 블록에서 라인 넘버를 보고 싶습니다. 그래야 다른 사람과 코드를 논의할 때 특정 라인을 참조할 수 있습니다.

#### 수용 기준

1. WHEN 코드 블록이 렌더링되면, THE System SHALL 각 코드 라인의 왼쪽에 정렬된 라인 넘버를 표시한다
2. WHEN 사용자가 코드 텍스트를 선택하면, THE System SHALL 선택 영역에서 라인 넘버를 제외한다
3. WHEN 코드 블록이 여러 라인을 포함하면, THE System SHALL 1부터 시작하여 각 라인을 순차적으로 번호를 매긴다
4. WHILE 뷰포트가 리사이즈되면, THE System SHALL 라인 넘버와 코드 내용 사이의 적절한 정렬을 유지한다

### 요구사항 3

**사용자 스토리:** 독자로서, 코드 블록에 프로그래밍 언어 레이블을 보고 싶습니다. 그래야 코드를 읽지 않고도 언어를 빠르게 식별할 수 있습니다.

#### 수용 기준

1. WHEN 언어 메타데이터가 있는 코드 블록이 렌더링되면, THE System SHALL 언어 이름을 레이블로 표시한다
2. WHEN 코드 블록에 언어 메타데이터가 없으면, THE System SHALL 기본 레이블을 표시하거나 레이블을 표시하지 않는다
3. WHEN 언어 레이블이 표시되면, THE System SHALL 코드 블록에 대해 일관된 위치에 배치한다

### 요구사항 4

**사용자 스토리:** 독자로서, 긴 글에 대한 목차를 보고 싶습니다. 그래야 관심 있는 섹션으로 빠르게 이동할 수 있습니다.

#### 수용 기준

1. WHEN MDX 문서가 렌더링되면, THE System SHALL AST에서 모든 h2 및 h3 헤딩 요소를 추출한다
2. WHEN 헤딩이 추출되면, THE System SHALL 헤딩 레벨을 보존하는 계층적 TOC 구조를 생성한다
3. WHEN TOC가 표시되면, THE System SHALL 각 헤딩을 클릭 가능한 링크로 렌더링한다
4. WHEN 사용자가 TOC 링크를 클릭하면, THE System SHALL 뷰포트를 해당 헤딩으로 스크롤한다
5. WHERE MDX 문서가 2개 미만의 헤딩을 포함하면, THE System SHALL TOC를 표시하지 않는다

### 요구사항 5

**사용자 스토리:** 독자로서, 목차에서 현재 읽고 있는 섹션을 보고 싶습니다. 그래야 긴 글을 스크롤하면서 맥락을 유지할 수 있습니다.

#### 수용 기준

1. WHILE 사용자가 문서를 스크롤하면, THE System SHALL Intersection Observer를 사용하여 뷰포트에 현재 보이는 헤딩을 감지한다
2. WHEN 헤딩이 보이게 되면, THE System SHALL 해당 TOC 항목을 하이라이트한다
3. WHEN 여러 헤딩이 보이면, THE System SHALL 가장 위에 보이는 헤딩에 해당하는 TOC 항목을 하이라이트한다
4. WHEN 사용자가 모든 헤딩을 지나 스크롤하면, THE System SHALL TOC에서 모든 하이라이트를 제거한다

### 요구사항 6

**사용자 스토리:** 독자로서, 목차를 통해 이동할 때 부드러운 스크롤을 원합니다. 그래야 전환을 따라가고 방향을 유지할 수 있습니다.

#### 수용 기준

1. WHEN 사용자가 TOC 링크를 클릭하면, THE System SHALL smooth behavior로 대상 헤딩으로 스크롤을 애니메이션한다
2. WHEN 스크롤 애니메이션이 완료되면, THE System SHALL 대상 헤딩을 뷰포트 상단 근처에 배치한다
3. IF 사용자가 애니메이션 중에 새로운 스크롤 작업을 시작하면, THEN THE System SHALL 현재 애니메이션을 취소하고 새로운 스크롤을 시작한다

### 요구사항 7

**사용자 스토리:** 독자로서, 글의 예상 읽기 시간을 보고 싶습니다. 그래야 지금 읽을 충분한 시간이 있는지 결정할 수 있습니다.

#### 수용 기준

1. WHEN MDX 문서가 처리되면, THE System SHALL 단어 수를 기반으로 읽기 시간을 계산한다
2. WHEN 읽기 시간을 계산할 때, THE System SHALL 평균 읽기 속도로 분당 200 단어를 사용한다
3. WHEN 읽기 시간이 1분 미만이면, THE System SHALL "1분 읽기"를 표시한다
4. WHEN 읽기 시간이 계산되면, THE System SHALL 가장 가까운 분으로 반올림한다
5. WHEN 포스트 상세 페이지가 렌더링되면, THE System SHALL 포스트 메타데이터 섹션에 읽기 시간을 표시한다

### 요구사항 8

**사용자 스토리:** 콘텐츠 작성자로서, 읽기 시간이 포스트 인덱스에 자동으로 포함되기를 원합니다. 그래야 독자가 추가 처리 없이 포스트 목록 페이지에서 읽기 시간을 볼 수 있습니다.

#### 수용 기준

1. WHEN index.json 생성 스크립트가 MDX 파일을 처리하면, THE System SHALL 읽기 시간을 계산하고 메타데이터에 포함한다
2. WHEN 포스트 목록 페이지가 index.json을 가져오면, THE System SHALL 각 포스트의 읽기 시간을 표시한다
3. WHEN 읽기 시간이 목록 페이지에 표시되면, THE System SHALL 상세 페이지와 동일한 형식을 사용한다

### 요구사항 9

**사용자 스토리:** 개발자로서, 향상된 마크다운 기능이 기존 MDX 렌더링 파이프라인과 작동하기를 원합니다. 그래야 전체 콘텐츠 시스템을 리팩토링할 필요가 없습니다.

#### 수용 기준

1. WHEN MDX 콘텐츠가 next-mdx-remote-client를 사용하여 렌더링되면, THE System SHALL 커스텀 컴포넌트를 통해 코드 블록 개선을 통합한다
2. WHEN TOC가 생성되면, THE System SHALL 원본 콘텐츠를 수정하지 않고 MDX AST를 파싱한다
3. WHEN 읽기 시간이 계산되면, THE System SHALL 렌더링 전에 원시 MDX 콘텐츠를 처리한다
4. WHILE 향상된 기능을 렌더링하면, THE System SHALL 기존 rehype 및 remark 플러그인과의 호환성을 유지한다

### 요구사항 10

**사용자 스토리:** 모바일 사용자로서, 목차가 접근 가능하고 콘텐츠를 가리지 않기를 원합니다. 그래야 작은 화면에서 편안하게 글을 탐색할 수 있습니다.

#### 수용 기준

1. WHEN 뷰포트 너비가 768 픽셀 미만이면, THE System SHALL TOC를 접을 수 있는 형식 또는 드로어 형식으로 렌더링한다
2. WHEN TOC가 모바일에서 접혀있으면, THE System SHALL 확장할 수 있는 버튼 또는 아이콘을 제공한다
3. WHEN 사용자가 모바일에서 TOC를 확장하면, THE System SHALL 레이아웃을 깨지 않고 콘텐츠를 오버레이하거나 밀어낸다
4. WHEN 사용자가 모바일에서 TOC 항목을 선택하면, THE System SHALL 네비게이션 후 자동으로 TOC를 접는다

### 요구사항 11

**사용자 스토리:** 독자로서, 코드 블록이 시각적으로 구별되고 잘 포맷되기를 원합니다. 그래야 일반 텍스트와 코드를 쉽게 구별할 수 있습니다.

#### 수용 기준

1. WHEN 코드 블록이 렌더링되면, THE System SHALL 기존 rehype-highlight 플러그인을 사용하여 구문 하이라이팅을 적용한다
2. WHEN 코드 블록이 렌더링되면, THE System SHALL 일관된 패딩과 마진 스페이싱을 적용한다
3. WHEN 코드 블록이 다크 모드에서 렌더링되면, THE System SHALL 구문 하이라이팅에 다크 테마를 사용한다
4. WHEN 코드 블록이 라이트 모드에서 렌더링되면, THE System SHALL 구문 하이라이팅에 라이트 테마를 사용한다
